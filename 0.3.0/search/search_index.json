{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Scrat Documentation","text":"<p>Welcome to the official documentation for Scrat</p> <p>To familiarize yourself with the library read our getting started guide.</p> <p>For more info about the API visit the reference</p>"},{"location":"getting_started/","title":"Gatting Started","text":""},{"location":"getting_started/#installation-and-setup","title":"Installation and Setup","text":""},{"location":"getting_started/#from-pypi","title":"From pypi","text":"<p>Simply run <code>pip install scrat</code></p>"},{"location":"getting_started/#from-github","title":"From Github","text":"<p>To install the latest version from github run <code>pip install git+https://github.com/javiber/scrat.git@main#egg=scrat</code></p>"},{"location":"getting_started/#setup","title":"Setup","text":"<p>Before using scrat you need to initialize the cache first by running <code>scrat init</code>. This will create a folder <code>.scrat</code> in the current directory which contains the <code>stash</code> folder where the results are saved and a sqlite file (<code>stash.db</code>) where we index the results.</p>"},{"location":"getting_started/#basic-usage","title":"Basic Usage","text":"<p>The most basic use-case is to cache the results of slow functions, let's create a slow function and call it from a python script:</p> <pre><code># sample.py\nimport time\n\nimport scrat as sc\n\n\n@sc.stash()\ndef slow_square(a):\n    time.sleep(1)\n    return a**2\n\n\nif __name__ == \"__main__\":\n    a = 2\n    t0 = time.time()\n    result = slow_square(a)\n    t1 = time.time()\n    print(f\"Function took {t1-t0:.1f}s, the square of {a} is {result}\")\n</code></pre> <p>Now we call the script from the console:</p> <pre><code>&gt; python sample.py\nFunction took 1.0s, the square of 2 is 4\n\n&gt; python sample.py\nFunction took 0.0s, the square of 2 is 4\n\n&gt; scrat stash list\nname        hash                             created_at       size\nslow_square 724c8df5b6e9961d194ee0e24e385d44 2023-08-08 15:29 5.0B\n</code></pre> <p>Notice that the second time we called the scrip, the result is recovered from the stash saving us the 1 second execution time.</p> <p>Next, change the parameter <code>a</code> to <code>4</code> in line <code>13</code> and call the script again.</p> <pre><code>&gt; python sample.py\nFunction took 1.0s, the square of 4 is 16\n\n&gt; scrat stash list\nname        hash                             created_at       size\nslow_square 724c8df5b6e9961d194ee0e24e385d44 2023-08-08 15:29 5.0B\nslow_square 589e5491ea30ed09f40e117078a302ef 2023-08-08 15:30 5.0B\n</code></pre> <p>Since we changed the parameters, the function is called again and a new entry is added to the stash.</p> <p>Finally, change the function's code in line <code>9</code> to make it return the cube of <code>a</code>, <code>a**3</code> and call the script one more time:</p> <pre><code>&gt; python sample.py\nFunction took 1.0s, the square of 4 is 64\n\n&gt; scrat stash list\nname        hash                             created_at       size\nslow_square 724c8df5b6e9961d194ee0e24e385d44 2023-08-08 15:29 5.0B\nslow_square 589e5491ea30ed09f40e117078a302ef 2023-08-08 15:30 5.0B\nslow_square e74a0c542fab2c6280e21d48a4fc916d 2023-08-08 15:32 5.0B\n</code></pre> <p>Scrat notices that the function code has changed so it calls it again.</p> <p>Scrat is ideal to store the results of any deterministic and expensive function such as complex calculations or queries.</p>"},{"location":"getting_started/#serializer","title":"Serializer","text":""},{"location":"getting_started/#specifying-a-built-in-serializer","title":"Specifying a built-in serializer","text":"<p>By default Scrat will use pickle to store the results in disk as it can handle a wide variety of objects, however, there are better alternatives if you know the result's type.</p> <p>For instance, you can easily switch to using json by specifying the serializer like this:</p> <pre><code># json_serializer.py\nimport scrat as sc\n\n\n@sc.stash(serializer=sc.JsonSerializer())\ndef get_results():\n    print(\"function called\")\n    return [{\"result\": 1}, {\"result\": 2}]\n\n\nif __name__ == \"__main__\":\n    print(get_results())\n</code></pre> <p>Now let's run the script</p> <pre><code>&gt; python json_serializer.py\nfunction called\n[{'result': 1}, {'result': 2}]\n&gt; python json_serializer.py\n[{'result': 1}, {'result': 2}]\n&gt; scrat stash list\nname        hash                             created_at       size\nget_results cdd21f31ae5589a465175765f0fb545d 2023-08-14 23:16 30.0B\n&gt; cat .scrat/stash/get_results_cdd21f31ae5589a465175765f0fb545d\n[{\"result\": 1}, {\"result\": 2}]\n</code></pre> <p>You can find the list of built-in serializers here</p>"},{"location":"getting_started/#specifying-the-return-type","title":"Specifying the Return Type","text":"<p>Scrat will also choose a better serializer if you indicate the return type of your function, For instance:</p> <pre><code># numpy_serializer.py\nimport numpy as np\nimport scrat as sc\n\n@sc.stash()\ndef np_func(size) -&gt; np.ndarray:\n    print(\"function called\")\n    return np.eye(size)\n\nif __name__ == \"__main__\":\n    print(np_func(3))\n</code></pre> <p>By adding the typehint, Scrat will automatically use the NumpySerializer which relies on the <code>numpy.save</code> and <code>numpy.load</code> methods.</p>"},{"location":"getting_started/#custom-serializer","title":"Custom Serializer","text":"<p>We are working on adding more serializers (pull requests are welcome \ud83d\ude09), in the meantime, we made sure that adding a custom Serializer can be done by implementing a simple interface:</p> <pre><code># custom_serializer.py\nfrom pathlib import Path\n\nimport torch\n\nimport scrat as sc\n\n\nclass TorchSerializer(sc.Serializer):\n    def load(self, path: Path) -&gt; torch.Tensor:\n        return torch.load(path)\n\n    def dump(self, obj: torch.Tensor, path: Path):\n        torch.save(obj, path)\n\n\n@sc.stash(serializer=TorchSerializer())\ndef func():\n    print(\"Function called\")\n    return torch.ones((3, 3))\n\n\nif __name__ == \"__main__\":\n    print(func())\n</code></pre> <pre><code>&gt; python custom_serializer.py\nFunction called\ntensor([[1., 1., 1.],\n        [1., 1., 1.],\n        [1., 1., 1.]])\n&gt; python custom_serializer.py\ntensor([[1., 1., 1.],\n        [1., 1., 1.],\n        [1., 1., 1.]])\n&gt; scrat stash list\nname       hash                             created_at       size\nfunc       2f7059606083e1f5a1390a16900fce3a 2023-08-14 23:31 965.0B\n</code></pre>"},{"location":"getting_started/#hashing","title":"Hashing","text":"<p>Hashing is a very important concept, each time you invoke a stashed function a hash is calculated and used to search for a stored result. By default, the hash includes the arguments and the function's code so you always get the correct behavior if your function meets this 3 conditions:</p> <ul> <li>deterministic (i.e. the output is not random or random seeds are fixed)</li> <li>doesn't access global variables that could change</li> <li>doesn't call another functions that could change</li> </ul> <p>The first point is self-explanatory, Scrat can't guess if the result of a random function is going to change or not but the other 2 points are worth discussing further.</p>"},{"location":"getting_started/#global-variables","title":"Global Variables","text":"<p>Here is a function that access a global variable:</p> <pre><code># global_var.py\nimport scrat as sc\n\nGLOBAL_VAR = 2\n\n\n@sc.stash()\ndef sum_global(a=1):\n    print(\"Function called\")\n    return a + GLOBAL_VAR\n\n\nif __name__ == \"__main__\":\n    a = 1\n    # The First call gets the correct result\n    print(f\"{a}+{GLOBAL_VAR}={sum_global(1)}\")\n\n    GLOBAL_VAR = 3\n    # The function and the parameters have not changed so Scrat will return the old\n    # value of 3.\n    # This happens because GLOBAL_VAR is not being considered in the hash\n    print(f\"{a}+{GLOBAL_VAR}={sum_global(1)}\")\n\n</code></pre> <p>Luckely, this is easily fixable by adding a watched global variable:</p> <pre><code># global_car_fixed.py\nimport scrat as sc\n\nGLOBAL_VAR = 2\n\n\n@sc.stash(watch_globals=[\"GLOBAL_VAR\"])\ndef sum_global(a=1):\n    print(\"Function called\")\n    return a + GLOBAL_VAR\n\n\nif __name__ == \"__main__\":\n    a = 1\n    # The First call gets the correct result\n    print(f\"{a}+{GLOBAL_VAR}={sum_global(1)}\")\n\n    GLOBAL_VAR = 3\n    # And the second one does too\n    print(f\"{a}+{GLOBAL_VAR}={sum_global(1)}\")\n</code></pre> <p>Now the behavior is corrected:</p> <pre><code>&gt; python global_var_fixed.py\nFunction called\n1+2=3\nFunction called\n1+3=4\n</code></pre>"},{"location":"getting_started/#nested-functions","title":"Nested Functions","text":"<p>Similarly if your function calls another function which code changed, Scrat is not going to notice and it will return the old result but, again, this is easily fixable by adding a watched function:</p> <pre><code># nested_function.py\nimport scrat as sc\n\n\ndef nested_func():\n    return 2\n\n\n@sc.stash(watch_functions=[nested_func])\ndef func(a=1):\n    print(\"Function called\")\n    return a + nested_func()\n\n\nif __name__ == \"__main__\":\n    print(func(1))\n</code></pre> <p>Now if you ever change the result of nested_func, the function is going to be re-run.</p>"},{"location":"getting_started/#ignore-arguments","title":"Ignore Arguments","text":"<p>By default, Scrat assumes that all the arguments affect the result which might not allways be true. For instance some arguments might only affect the logging and thus should not be included in the hash this can be controlled using the <code>ignore_args</code>:</p> <pre><code># ignore_argmuents.py\nimport scrat as sc\n\n@sc.stash(ignore_args=[\"verbose\"])\ndef double(a, verbose):\n    if verbose:\n        print(f\"Function called with verbose={verbose}\")\n    else:\n        print(\"Function called\")\n    return a * 2\n\n\nif __name__ == \"__main__\":\n    print(double(1, verbose=True))\n    print(double(1, verbose=False))\n</code></pre>"},{"location":"getting_started/#force-hasher","title":"Force Hasher","text":"<p>Scrat tries to use a sane hasher according to the type of each argument, unfurtunatelly, this can fail. We are working on making this process more robust but in the meantime, if you encounter any issue you can control which hasher is used for each argument:</p> <pre><code># force_hasher.py\nimport numpy as np\n\nimport scrat as sc\n\n\n@sc.stash(hashers={\"a\": sc.NumpyHasher()})\ndef double(a):\n    return a * 2\n\n\nif __name__ == \"__main__\":\n    print(double(np.arange(10)))\n</code></pre> <p>This is useful if you want to change the default parameters of some of the hashers, for more info about the available hashers, check this doc.</p>"},{"location":"getting_started/#custom-hasher","title":"Custom Hasher","text":"<p>Adding a custom hasher is easy, you just need to implement a simple interface and tell scrat which parameters should use it:</p> <pre><code># custom_hasher.py\nimport torch\n\nimport scrat as sc\n\n\nclass TorchHasher(sc.hasher.Hasher):\n    def hash(self, value: torch.Tensor) -&gt; str:\n        return self.md5_hash(value.numpy())\n\n\n@sc.stash(hashers={\"a\": TorchHasher()})\ndef double(a):\n    return a * 2\n\n\nif __name__ == \"__main__\":\n    print(double(torch.arange(10)))\n</code></pre> <p>The class Hasher provides the method md5_hash that turns any string of buffer into an md5 digest, we encourage you to use it in your custom Hashers.</p>"},{"location":"getting_started/#class-methods","title":"Class Methods","text":"<p>Warning</p> <p>Currently scrat can't does not include any binded argument (such as <code>self</code>) to the hash. We plan to add this feature shortly.</p>"},{"location":"reference/","title":"Index","text":"<p>Scrat Library</p>"},{"location":"reference/#scrat.stash","title":"<code>stash(serializer=None, name=None, hashers=None, hash_code=True, ignore_args=None, watch_functions=None, watch_globals=None, force=None, disable=None, max_size=None, cache_policy=CachePolicy.lru)</code>","text":"<p>Wrap a function to stash the results</p> <p>Parameters:</p> Name Type Description Default <code>serializer</code> <code>Optional[Serializer]</code> <p>Select a serializer for the function's result, by default a good serializer is inferred from the typehint, using <code>PickleSerializer</code> as the fallback.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Name that identifies this function, by default the function name is used.</p> <code>None</code> <code>hashers</code> <code>Optional[Dict[str, Hasher]]</code> <p>Dictionary specifying hashers used for the arguments, by default hashers are selected according to the type of the argument, using <code>ToStringHasher</code> as the fallback.</p> <code>None</code> <code>hash_code</code> <code>Optional[bool]</code> <p>Control if the function's code should be used in the hash, by default True.</p> <code>True</code> <code>ignore_args</code> <code>Optional[List[str]]</code> <p>List of arguments to ignore from the hash, by default None</p> <code>None</code> <code>watch_functions</code> <code>Optional[List[Any]]</code> <p>List of functions which code should be included in the hash, by default None</p> <code>None</code> <code>watch_globals</code> <code>Optional[List[str]]</code> <p>List of global variables to include in the hash, by default None</p> <code>None</code> <code>force</code> <code>Optional[bool]</code> <p>If set to True the stash is ignored, the function is called and the result is saved to the stash, by default the global setting <code>scrat.Setting.force</code> is used</p> <code>None</code> <code>disable</code> <code>Optional[bool]</code> <p>If set to True the stash is ignored, the function called and the result is not saved, by default the global setting <code>scrat.Setting.disable</code> is used</p> <code>None</code> <code>max_size</code> <code>Optional[int]</code> <p>Maximum size allowed for files of this function, if the limit is about to be met other files are removed befor storing a new one based on the cache_policy</p> <code>None</code> <code>cache_policy</code> <code>CachePolicy</code> <p>Cache policy, by default Least Recentrly Used (LRU) is applied</p> <code>lru</code>"},{"location":"reference/#scrat.stash--notes","title":"Notes","text":"<p>If possible, avoid using the default <code>PickleSerializer</code>. This serializer is used by default because it works with most objects but pickle is not a good format to store the results long-term. We encourage users to select one the other serializers provided or writing a custom one.</p> <p>Examples:</p> <p>Simple example</p> <pre><code>&gt;&gt;&gt; import scrat as sc\n&gt;&gt;&gt; @sc.stash()\n&gt;&gt;&gt; def funcion():\n&gt;&gt;&gt;     return 1\n</code></pre> <p>Custom serializer</p> <pre><code>&gt;&gt;&gt; @sc.stash(serializer=sc.JsonSerializer())\n&gt;&gt;&gt; def funcion():\n&gt;&gt;&gt;     return {\"json\": True}\n</code></pre> Source code in <code>scrat/decorator.py</code> <pre><code>def stash(\n    serializer: T.Optional[Serializer] = None,\n    name: T.Optional[str] = None,\n    hashers: T.Optional[T.Dict[str, Hasher]] = None,\n    hash_code: T.Optional[bool] = True,\n    ignore_args: T.Optional[T.List[str]] = None,\n    watch_functions: T.Optional[T.List[T.Any]] = None,\n    watch_globals: T.Optional[T.List[str]] = None,\n    force: T.Optional[bool] = None,\n    disable: T.Optional[bool] = None,\n    max_size: T.Optional[int] = None,\n    cache_policy: CachePolicy = CachePolicy.lru,\n):\n    \"\"\"Wrap a function to stash the results\n\n    Parameters\n    ----------\n    serializer\n        Select a serializer for the function's result, by default a good\n        serializer is inferred from the typehint, using `PickleSerializer` as\n        the fallback.\n    name\n        Name that identifies this function, by default the function name is used.\n    hashers\n        Dictionary specifying hashers used for the arguments, by default hashers\n        are selected according to the type of the argument, using `ToStringHasher`\n        as the fallback.\n    hash_code\n        Control if the function's code should be used in the hash, by default True.\n    ignore_args\n        List of arguments to ignore from the hash, by default None\n    watch_functions\n        List of functions which code should be included in the hash, by default None\n    watch_globals\n        List of global variables to include in the hash, by default None\n    force\n        If set to True the stash is ignored, the function is called and the result\n        is saved to the stash, by default the global setting `scrat.Setting.force` is\n        used\n    disable\n        If set to True the stash is ignored, the function called and the result\n        is **not** saved, by default the global setting `scrat.Setting.disable` is used\n    max_size\n        Maximum size allowed for files of this function, if the limit is about to be met\n        other files are removed befor storing a new one based on the cache_policy\n    cache_policy\n        Cache policy, by default Least Recentrly Used (LRU) is applied\n\n    Notes\n    -----\n    If possible, avoid using the default `PickleSerializer`. This serializer is used by\n    default because it works with most objects but pickle is not a good format to store\n    the results long-term. We encourage users to select one the other serializers\n    provided or writing a custom one.\n\n    Examples\n    --------\n\n    Simple example\n\n    &gt;&gt;&gt; import scrat as sc\n    &gt;&gt;&gt; @sc.stash()\n    &gt;&gt;&gt; def funcion():\n    &gt;&gt;&gt;     return 1\n\n    Custom serializer\n\n    &gt;&gt;&gt; @sc.stash(serializer=sc.JsonSerializer())\n    &gt;&gt;&gt; def funcion():\n    &gt;&gt;&gt;     return {\"json\": True}\n    \"\"\"\n\n    def deco(func):\n        squirrel = Squirrel(\n            hashers=hashers,\n            name=name if name is not None else func.__name__,\n            ignore_args=ignore_args,\n            hash_code=hash_code,\n            watch_functions=watch_functions,\n            watch_globals=watch_globals,\n            serializer=serializer\n            if serializer is not None\n            else get_default_serializer(func),\n            force=force,\n            disable=disable,\n            max_size=max_size,\n            cache_policy=cache_policy,\n        )\n\n        timer = Timer()\n\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            hash_key = squirrel.hash(args, kwargs, func)\n            if squirrel.exists(hash_key):\n                logger.info(\"Cache hit %s\", hash_key)\n                return squirrel.fetch(hash_key)\n\n            logger.info(\"Cache miss %s\", hash_key)\n            timer.start()\n            result = func(*args, **kwargs)\n            func_time = timer.end()\n\n            squirrel.stash(hash_key=hash_key, time_s=func_time, result=result)\n\n            return result\n\n        return wrapper\n\n    return deco\n</code></pre>"},{"location":"reference/hasher/","title":"Hashers","text":"<p>Module containing all Hashers</p>"},{"location":"reference/hasher/#scrat.hasher.Hasher","title":"<code>Hasher</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract class from which all Hashers inherit from</p> Source code in <code>scrat/hasher/base.py</code> <pre><code>class Hasher(ABC):\n    \"Abstract class from which all Hashers inherit from\"\n\n    @abstractmethod\n    def hash(self, value: T.Any) -&gt; str:\n        \"\"\"Calculate the hash-string corresponding to a value\n\n        Parameters\n        ----------\n        value\n            The argument value\n\n        Returns\n        -------\n            The hash-string\n        \"\"\"\n        return NotImplemented\n\n    @classmethod\n    def md5_hash(cls, *args) -&gt; str:\n        \"\"\"\n        Generate the hash for strings and bytes using md5\n\n        Returns\n        -------\n            the resulting hexdigest\n        \"\"\"\n        h = hashlib.md5()\n        for value in args:\n            if isinstance(value, str):\n                value = value.encode()\n            h.update(value)\n        return h.hexdigest()\n</code></pre>"},{"location":"reference/hasher/#scrat.hasher.Hasher.hash","title":"<code>hash(value)</code>  <code>abstractmethod</code>","text":"<p>Calculate the hash-string corresponding to a value</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The argument value</p> required <p>Returns:</p> Type Description <code>    The hash-string</code> Source code in <code>scrat/hasher/base.py</code> <pre><code>@abstractmethod\ndef hash(self, value: T.Any) -&gt; str:\n    \"\"\"Calculate the hash-string corresponding to a value\n\n    Parameters\n    ----------\n    value\n        The argument value\n\n    Returns\n    -------\n        The hash-string\n    \"\"\"\n    return NotImplemented\n</code></pre>"},{"location":"reference/hasher/#scrat.hasher.Hasher.md5_hash","title":"<code>md5_hash(*args)</code>  <code>classmethod</code>","text":"<p>Generate the hash for strings and bytes using md5</p> <p>Returns:</p> Type Description <code>    the resulting hexdigest</code> Source code in <code>scrat/hasher/base.py</code> <pre><code>@classmethod\ndef md5_hash(cls, *args) -&gt; str:\n    \"\"\"\n    Generate the hash for strings and bytes using md5\n\n    Returns\n    -------\n        the resulting hexdigest\n    \"\"\"\n    h = hashlib.md5()\n    for value in args:\n        if isinstance(value, str):\n            value = value.encode()\n        h.update(value)\n    return h.hexdigest()\n</code></pre>"},{"location":"reference/hasher/#scrat.hasher.IterableHasher","title":"<code>IterableHasher</code>","text":"<p>             Bases: <code>Hasher</code></p> <p>Apply one Hasher to each element of a iterable</p> <p>Parameters:</p> Name Type Description Default <code>item_hasher</code> <code>Hasher</code> <p>A Hasher to hash each value in the iterable</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import scrat as sc\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; hasher = sc.IterableHasher(sc.NumpyHasher())\n&gt;&gt;&gt; hasher.hash([np.zeros(5), np.ones(3)])\n'f86f4d4c12a426ce5d54d715723584be'\n</code></pre> Source code in <code>scrat/hasher/iterable.py</code> <pre><code>class IterableHasher(Hasher):\n    \"\"\"\n    Apply one Hasher to each element of a iterable\n\n    Parameters\n    ----------\n    item_hasher\n        A Hasher to hash each value in the iterable\n\n    Examples\n    --------\n    &gt;&gt;&gt; import scrat as sc\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; hasher = sc.IterableHasher(sc.NumpyHasher())\n    &gt;&gt;&gt; hasher.hash([np.zeros(5), np.ones(3)])\n    'f86f4d4c12a426ce5d54d715723584be'\n    \"\"\"\n\n    def __init__(self, item_hasher: Hasher) -&gt; None:\n        super().__init__()\n        self.item_hasher = item_hasher\n\n    def hash(self, value: T.Iterable) -&gt; str:\n        return self.md5_hash(*[self.item_hasher.hash(x) for x in value])\n</code></pre>"},{"location":"reference/hasher/#scrat.hasher.NumpyHasher","title":"<code>NumpyHasher</code>","text":"<p>             Bases: <code>Hasher</code></p> <p>Hasher for numpy arrays</p> Source code in <code>scrat/hasher/numpy.py</code> <pre><code>class NumpyHasher(Hasher):\n    \"Hasher for numpy arrays\"\n\n    def hash(self, value: T.Any) -&gt; str:\n        return self.md5_hash(value)\n</code></pre>"},{"location":"reference/hasher/#scrat.hasher.PandasHasher","title":"<code>PandasHasher</code>","text":"<p>             Bases: <code>Hasher</code></p> <p>Hasher for Pandas Series and DataFrames</p> <p>Parameters:</p> Name Type Description Default <code>use_values</code> <code>bool</code> <p>If False, only the index of the dataframe is included in the hash This can help with the speed of the hasher on big dataframes where you only care what rows are included but you know the values don't change, by default True</p> <code>True</code> Source code in <code>scrat/hasher/pandas.py</code> <pre><code>class PandasHasher(Hasher):\n    \"\"\"\n    Hasher for Pandas Series and DataFrames\n\n    Parameters\n    ----------\n    use_values\n        If False, only the index of the dataframe is included in the hash\n        This can help with the speed of the hasher on big dataframes where\n        you only care what rows are included but you know the values\n        don't change, by default True\n    \"\"\"\n\n    def __init__(self, use_values: bool = True) -&gt; None:\n        super().__init__()\n        self.use_values = use_values\n\n    def hash(self, value: T.Any) -&gt; str:\n        if self.use_values:\n            return self.md5_hash(value.index.values, value.values)\n        return self.md5_hash(value.index.values)\n</code></pre>"},{"location":"reference/hasher/#scrat.hasher.ToStringHasher","title":"<code>ToStringHasher</code>","text":"<p>             Bases: <code>Hasher</code></p> <p>Naive hasher that tries to conver the value to str and then hash it</p> Source code in <code>scrat/hasher/to_string.py</code> <pre><code>class ToStringHasher(Hasher):\n    \"Naive hasher that tries to conver the value to str and then hash it\"\n\n    def hash(self, value: T.Any) -&gt; str:\n        return self.md5_hash(str(value))\n</code></pre>"},{"location":"reference/serializer/","title":"Serializers","text":"<p>Module containing all Serializers</p>"},{"location":"reference/serializer/#scrat.serializer.Serializer","title":"<code>Serializer</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract class from which all Serializer inherit from.</p> Source code in <code>scrat/serializer/base.py</code> <pre><code>class Serializer(ABC):\n    \"\"\"\n    Abstract class from which all Serializer inherit from.\n    \"\"\"\n\n    @abstractmethod\n    def dump(self, obj: T.Any, path: Path):\n        \"\"\"\n        Save an object to disk.\n\n        Parameters\n        ----------\n        obj\n            The result to save.\n        path\n            The target location in the filesystem.\n        \"\"\"\n        return NotImplemented\n\n    @abstractmethod\n    def load(self, path: Path) -&gt; T.Any:\n        \"\"\"\n        Load a saved object from disk.\n\n        Parameters\n        ----------\n        path\n            Location of the stored result.\n\n        Returns\n        -------\n            The object loaded into memory.\n        \"\"\"\n        return NotImplemented\n</code></pre>"},{"location":"reference/serializer/#scrat.serializer.Serializer.dump","title":"<code>dump(obj, path)</code>  <code>abstractmethod</code>","text":"<p>Save an object to disk.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The result to save.</p> required <code>path</code> <code>Path</code> <p>The target location in the filesystem.</p> required Source code in <code>scrat/serializer/base.py</code> <pre><code>@abstractmethod\ndef dump(self, obj: T.Any, path: Path):\n    \"\"\"\n    Save an object to disk.\n\n    Parameters\n    ----------\n    obj\n        The result to save.\n    path\n        The target location in the filesystem.\n    \"\"\"\n    return NotImplemented\n</code></pre>"},{"location":"reference/serializer/#scrat.serializer.Serializer.load","title":"<code>load(path)</code>  <code>abstractmethod</code>","text":"<p>Load a saved object from disk.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Location of the stored result.</p> required <p>Returns:</p> Type Description <code>    The object loaded into memory.</code> Source code in <code>scrat/serializer/base.py</code> <pre><code>@abstractmethod\ndef load(self, path: Path) -&gt; T.Any:\n    \"\"\"\n    Load a saved object from disk.\n\n    Parameters\n    ----------\n    path\n        Location of the stored result.\n\n    Returns\n    -------\n        The object loaded into memory.\n    \"\"\"\n    return NotImplemented\n</code></pre>"},{"location":"reference/serializer/#scrat.serializer.DillSerializer","title":"<code>DillSerializer</code>","text":"<p>Serializer using dill.</p> <p>In order to use this Serializer dill needs to be installed.</p> <p>Parameters:</p> Name Type Description Default <code>dump_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>extra arguments for dill.dump, by default None</p> <code>None</code> <code>load_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>extra arguments for dill.load, by default None</p> <code>None</code> Source code in <code>scrat/serializer/dill.py</code> <pre><code>class DillSerializer:\n    \"\"\"\n    Serializer using dill.\n\n    In order to use this Serializer dill needs to be installed.\n\n    Parameters\n    ----------\n    dump_kwargs\n        extra arguments for dill.dump, by default None\n    load_kwargs\n        extra arguments for dill.load, by default None\n    \"\"\"\n\n    def __init__(\n        self,\n        dump_kwargs: T.Optional[T.Dict[str, T.Any]] = None,\n        load_kwargs: T.Optional[T.Dict[str, T.Any]] = None,\n    ) -&gt; None:\n        # test that dill is installed\n        import dill  # noqa: F401\n\n        self.dump_kwargs = dump_kwargs if dump_kwargs is not None else {}\n        self.load_kwargs = load_kwargs if load_kwargs is not None else {}\n\n    def dump(self, obj: T.Any, path: Path):\n        import dill\n\n        with open(path, \"wb\") as f:\n            dill.dump(obj, f, **self.dump_kwargs)\n\n    def load(self, path: Path) -&gt; T.Any:\n        import dill\n\n        with open(path, \"rb\") as f:\n            return dill.load(f, **self.load_kwargs)\n</code></pre>"},{"location":"reference/serializer/#scrat.serializer.JsonSerializer","title":"<code>JsonSerializer</code>","text":"<p>Serializer that uses json from the python standard library.</p> <p>Parameters:</p> Name Type Description Default <code>dump_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>Extra arguments for json.dump, by default None</p> <code>None</code> <code>load_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>Extra arguments for json.load, by default None</p> <code>None</code> Source code in <code>scrat/serializer/json.py</code> <pre><code>class JsonSerializer:\n    \"\"\"\n    Serializer that uses json from the python standard library.\n\n    Parameters\n    ----------\n    dump_kwargs\n        Extra arguments for json.dump, by default None\n    load_kwargs\n        Extra arguments for json.load, by default None\n    \"\"\"\n\n    def __init__(\n        self,\n        dump_kwargs: T.Optional[T.Dict[str, T.Any]] = None,\n        load_kwargs: T.Optional[T.Dict[str, T.Any]] = None,\n    ) -&gt; None:\n        self.dump_kwargs = dump_kwargs if dump_kwargs is not None else {}\n        self.load_kwargs = load_kwargs if load_kwargs is not None else {}\n\n    def dump(self, obj: T.Any, path: Path):\n        with open(path, \"w\") as f:\n            json.dump(obj, f, **self.dump_kwargs)\n\n    def load(self, path: Path) -&gt; T.Any:\n        with open(path, \"r\") as f:\n            return json.load(f, **self.load_kwargs)\n</code></pre>"},{"location":"reference/serializer/#scrat.serializer.NumpySerializer","title":"<code>NumpySerializer</code>","text":"<p>Serializer for numpy arrays.</p> <p>In order to use this Serializer numpy needs to be installed.</p> <p>Parameters:</p> Name Type Description Default <code>save_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>Extra arguments for numpy.save, by default None</p> <code>None</code> <code>load_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>Extra arguments for numpy.load, by default None</p> <code>None</code> Source code in <code>scrat/serializer/numpy.py</code> <pre><code>class NumpySerializer:\n    \"\"\"\n    Serializer for numpy arrays.\n\n    In order to use this Serializer numpy needs to be installed.\n\n\n    Parameters\n    ----------\n    save_kwargs\n        Extra arguments for numpy.save, by default None\n    load_kwargs\n        Extra arguments for numpy.load, by default None\n    \"\"\"\n\n    def __init__(\n        self,\n        save_kwargs: T.Optional[T.Dict[str, T.Any]] = None,\n        load_kwargs: T.Optional[T.Dict[str, T.Any]] = None,\n    ) -&gt; None:\n        # test that numpy is installed\n        import numpy  # noqa: F401\n\n        self.save_kwargs = save_kwargs if save_kwargs is not None else {}\n        self.load_kwargs = load_kwargs if load_kwargs is not None else {}\n\n    def dump(self, obj: \"np.ndarray\", path: Path):\n        import numpy\n\n        numpy.save(path, obj, **self.save_kwargs)\n        obj.save(path)\n\n    def load(self, path: Path) -&gt; \"np.ndarray\":\n        import numpy\n\n        return numpy.load(path, **self.load_kwargs)\n</code></pre>"},{"location":"reference/serializer/#scrat.serializer.PandasSerializer","title":"<code>PandasSerializer</code>","text":"<p>Serializer for Pandas Series and DataFrames.</p> <p>In order to use this Serializer pandas needs to be installed, some formats might need aditional libraries.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>Union[str, Format]</code> <p>Serialization method from the ones supported by pandas, by default Format.parquet</p> <code>parquet</code> <code>to_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>Extra arguments for the corresponding pandas.read_ function, by default None <code>None</code> <code>read_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>Extra arguments for the corresponding pandas.to_ function, by default None <code>None</code> Source code in <code>scrat/serializer/pandas.py</code> <pre><code>class PandasSerializer:\n    \"\"\"\n    Serializer for Pandas Series and DataFrames.\n\n    In order to use this Serializer pandas needs to be installed,\n    some formats might need aditional libraries.\n\n    Parameters\n    ----------\n    format\n        Serialization method from the ones supported by pandas,\n        by default Format.parquet\n    to_kwargs\n        Extra arguments for the corresponding pandas.read_&lt;format&gt; function,\n        by default None\n    read_kwargs\n        Extra arguments for the corresponding pandas.to_&lt;format&gt; function,\n        by default None\n    \"\"\"\n\n    def __init__(\n        self,\n        format: T.Union[str, Format] = Format.parquet,\n        to_kwargs: T.Optional[T.Dict[str, T.Any]] = None,\n        read_kwargs: T.Optional[T.Dict[str, T.Any]] = None,\n    ) -&gt; None:\n        # test that pandas is installed\n        import pandas  # noqa: F401\n\n        self.format = format if isinstance(format, Format) else Format(format)\n\n        self.to_kwargs = to_kwargs if to_kwargs is not None else {}\n        self.read_kwargs = read_kwargs if read_kwargs is not None else {}\n\n    def dump(self, obj: \"pd.DataFrame\", path: Path):\n        to_method = getattr(obj, f\"to_{self.format.value}\")\n        to_method(path, **self.to_kwargs)\n\n    def load(self, path: Path) -&gt; \"pd.DataFrame\":\n        import pandas\n\n        read_method = getattr(pandas, f\"read_{self.format.value}\")\n        return read_method(path, **self.read_kwargs)\n</code></pre>"},{"location":"reference/serializer/#scrat.serializer.PickleSerializer","title":"<code>PickleSerializer</code>","text":"<p>Pickle serializer.</p> <p>Parameters:</p> Name Type Description Default <code>dump_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>Extra arguments for pickle.dump, by default None</p> <code>None</code> <code>load_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>Extra arguments for pickle.load, by default None</p> <code>None</code> Source code in <code>scrat/serializer/pickle.py</code> <pre><code>class PickleSerializer:\n    \"\"\"\n    Pickle serializer.\n\n    Parameters\n    ----------\n    dump_kwargs\n        Extra arguments for pickle.dump, by default None\n    load_kwargs\n        Extra arguments for pickle.load, by default None\n    \"\"\"\n\n    def __init__(\n        self,\n        dump_kwargs: T.Optional[T.Dict[str, T.Any]] = None,\n        load_kwargs: T.Optional[T.Dict[str, T.Any]] = None,\n    ) -&gt; None:\n        self.dump_kwargs = dump_kwargs if dump_kwargs is not None else {}\n        self.load_kwargs = load_kwargs if load_kwargs is not None else {}\n\n    def dump(self, obj: T.Any, path: Path):\n        with open(path, \"wb\") as f:\n            pickle.dump(obj, f, **self.dump_kwargs)\n\n    def load(self, path: Path) -&gt; T.Any:\n        with open(path, \"rb\") as f:\n            return pickle.load(f, **self.load_kwargs)\n</code></pre>"},{"location":"reference/serializer/#scrat.serializer.get_default_serializer","title":"<code>get_default_serializer(func)</code>","text":"<p>Try to find a sane serializer using the function's typehint.</p> <p>Defaults to <code>PickleSerializer</code></p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The user function to be called</p> required <p>Returns:</p> Type Description <code>    An instance of the chosen Serializer</code> Source code in <code>scrat/serializer/__init__.py</code> <pre><code>def get_default_serializer(func: T.Callable) -&gt; Serializer:\n    \"\"\"\n    Try to find a sane serializer using the function's typehint.\n\n    Defaults to `PickleSerializer`\n\n    Parameters\n    ----------\n    func\n        The user function to be called\n\n    Returns\n    -------\n        An instance of the chosen Serializer\n    \"\"\"\n    import inspect\n\n    sign = inspect.signature(func)\n    if hasattr(sign, \"return_annotations\"):\n        return DEFAULT_SERIALIZERS.get(\n            sign.return_annotation.__name__, PickleSerializer\n        )()\n\n    return PickleSerializer()\n</code></pre>"}]}